#!/usr/bin/perl

use strict;
use DBI;
use JSON qw( decode_json );
use Data::Dumper;

binmode(STDOUT, ":encoding(UTF-8)");

my @envVars = ('DB_NAME', 'DB_USER', 'DB_PASS');
for my $envVar (@envVars) { die "Missing env variable '$envVar'\n" unless $ENV{$envVar}; }

my ($project, $tinydbFilePath, $udJsonFilePath, $targetDir, $maxUdId, $vdiSchemaSuffix, $dblinkName) = @ARGV;

die "Usage: project testMigration tinydbFilePath udJsonFilePath targetDir maxUdId vdiSchemaSuffix [dblinkName]\n" unless scalar(@ARGV) > 4;

die "Target dir '$targetDir' does not exist\n" unless -d $targetDir;

my $dbh = DBI->connect("dbi:Oracle:$ENV{DB_NAME}", $ENV{DB_USER}, $ENV{DB_PASS})
    || die "Couldn't connect to database: " . DBI->errstr;

$dbh->{RaiseError} = 1;
$dbh->{LongTruncOk} = 1;

my $DBLINK = "\@$dblinkName" if $dblinkName;

my $vdiDatasetsSchema = "VDI_DATASETS_$vdiSchemaSuffix";
my $vdiControlSchema = "VDI_CONTROL_$vdiSchemaSuffix";
my $idMapTable = "vdiUdIdMap_$vdiSchemaSuffix";

my $importedUds = writeIdMapToDb($tinydbFilePath, $dbh, $idMapTable);
my ($wdkUdIds, $expectedUdFiles) = readWdkJson($udJsonFilePath, $importedUds, $project);
my $legacyInstallStatus = findLegacyInstallStatus($dbh);
my $vdiInstallStatus = findVdiInstallStatus($dbh, $vdiControlSchema, $idMapTable);

if ($project eq 'MicrobiomeDB') { 
  print STDERR "Testing EDA\n";
  print STDOUT "MISSING BIOM FILES\n";
  testFiles($importedUds, $targetDir, $expectedUdFiles, 'BIOM', $vdiInstallStatus);
  testEda($dbh, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $project);
} elsif ( $project eq 'ClinEpiDB') {
  print STDERR "Testing EDA\n";
  print STDOUT "MISSING ISASIMPLE FILES\n";
  testFiles($importedUds, $targetDir, $expectedUdFiles, 'ISA', $vdiInstallStatus);
  testEda($dbh, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $project);
} else {
  print STDERR "Testing Gene List\n";
  testGeneList($dbh, $project, $vdiDatasetsSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);

  print STDERR "Testing RNA Seq\n";
  testRnaSeq($dbh, $project, $vdiDatasetsSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $targetDir, $expectedUdFiles);

  print STDERR "Testing Bigwig\n";
  testBigwig($importedUds, $targetDir, $expectedUdFiles, $vdiInstallStatus);
}

print STDERR "Testing Shares\n";
testShares($dbh, $project, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);

# create table XXXXX ( udId number, vdiId varchar(100), valid number);
sub writeIdMapToDb {
  my ($tinydbFilePath, $dbh, $idMapTable) = @_;

  open my $fh, '<', $tinydbFilePath or die "error opening $tinydbFilePath: $!";
  my $tinyJson = do { local $/; <$fh> };

  my $tiny = decode_json($tinyJson)->{'_default'};

  my $sth = $dbh->prepare("select table_name FROM user_TABLES WHERE TABLE_NAME = upper('$idMapTable')");
  $sth->execute();
  my ($t) = $sth->fetchrow_array;
  $dbh->do("create table $idMapTable (udId number, vdiId varchar(100), valid number)") unless $t;

  $dbh->do("truncate table $idMapTable");

  my $sth = $dbh->prepare(<<EOF);
    INSERT INTO $idMapTable
    VALUES (?,?,?)
EOF

  my $importedUds = {};
  foreach my $record (keys %$tiny) {
    my $msg = $tiny->{$record}->{msg};
    my $valid = $msg? 0 : 1;
    my $udId = $tiny->{$record}->{udId};
    $sth->execute($udId, $tiny->{$record}->{vdiId}, $valid);
    $importedUds->{$udId} = {valid=>$valid, msg=>$msg, vdiId=>$tiny->{$record}->{vdiId}};
  }
  return $importedUds;
}

sub readWdkJson {
  my ($jsonFilePath, $importedUds, $project) = @_;

  open my $fh, '<', $jsonFilePath or die "error opening $jsonFilePath: $!";
  my $wdkJson = do { local $/; <$fh> };

  my $wdk = decode_json($wdkJson);

  my $expectedUdFiles = {};
  my $wdkUdIds = {};
  my $count = 0;
  foreach my $ud (@$wdk) {
    my $type = $ud->{type}->{name};
    next unless $project eq $ud->{projects}->[0];
    $count++;
    $wdkUdIds->{$ud->{id}} = $ud->{ownerUserId};
#    next unless $type eq 'RnaSeq' or $type eq 'BigwigFiles';
    my $datafiles = $ud->{datafiles};
    $expectedUdFiles->{$type}->{$ud->{id}} = [];
    my $files = $expectedUdFiles->{$type}->{$ud->{id}};
    foreach my $datafile (@$datafiles) {
      my $name = $datafile->{name};
      next unless $name =~ /bw$/ || $name eq 'install.json';
      push(@$files, $name);
    }
    if ($type eq 'ISA' || $type eq 'BIOM') {
      push(@$files, 'install.json');
    }
  }
  print STDERR "Found $count wdk records to test\n";
  return ($wdkUdIds, $expectedUdFiles);
}

sub findLegacyInstallStatus {
  my ($dbh) = @_;

  my $sql = "
select user_dataset_id, is_invalid from APIDBUSERDATASETS.installeduserdataset$DBLINK
";

  my $legacyInstallStatus = {};
  my $sth = $dbh->prepare($sql);
  $sth->execute();
  while (my @row = $sth->fetchrow_array) {
    $legacyInstallStatus->{$row[0]} = $row[1]? "invalid" : "valid";
  }
  my $sql = "
select user_dataset_id from APIDBUSERDATASETS.UserDatasetEvent$DBLINK where (status != 'complete' and event_type = 'install') or (event_type = 'uninstall' and status = 'complete')
";

  my $sth = $dbh->prepare($sql);
  $sth->execute();
  while (my @row = $sth->fetchrow_array) {
    $legacyInstallStatus->{$row[0]} = "incomplete";
  }
  return $legacyInstallStatus;
}


sub findVdiInstallStatus {
  my ($dbh, $vdiControlSchema, $idMapTable) = @_;
  my $sql = "
select ids.udid, status, message from $vdiControlSchema.dataset_install_message m, $idMapTable ids
where m.install_type = 'data'
and ids.vdiid = m.dataset_id
";

my $vdiInstallStatus = {};
my $sth = $dbh->prepare($sql);
  $sth->execute();
  while (my @row = $sth->fetchrow_array) {
    $vdiInstallStatus->{$row[0]} = {status=>$row[1], msg=>$row[2]};
  }
  return $vdiInstallStatus;
}

sub testEda {
  my ($dbh, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $project) = @_;

  testEdaEntityTypeGraph($dbh, $vdiDatasetsSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $project);
  testEdaStudySpecificTables($dbh, $project, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);
}

sub testEdaEntityTypeGraph {
  my ($dbh, $vdiDatasetsSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $project) = @_;

  my $vdiSql = "
select id.udId, description, display_name, display_name_plural, has_attribute_collections, is_many_to_one_with_parent, cardinality
from $idMapTable id, $vdiDatasetsSchema.entitytypegraph etg, $vdiDatasetsSchema.study s, $vdiControlSchema.dataset_project p
where s.user_dataset_id = id.vdiId
and etg.study_stable_id = s.stable_id
and p.project_id = '$project'
and p.dataset_id = id.vdiId
and id.udId < $maxUdId
";

  my $legacySql = "
select d.user_dataset_id,  etg.description, display_name, display_name_plural, has_attribute_collections, is_many_to_one_with_parent, cardinality
from apidbuserdatasets.datasetattributes$DBLINK d, apidbuserdatasets.entitytypegraph$DBLINK etg, 
     apidbuserdatasets.UserDatasetEvent$DBLINK e, apidbuserdatasets.userdatasetproject$DBLINK p
where d.user_dataset_id < $maxUdId
and d.study_stable_id = etg.study_stable_id
AND p.user_dataset_id = d.user_dataset_id
AND p.project = '$project'
and e.user_dataset_id = d.user_dataset_id
and e.status = 'complete' and e.event_type = 'install'
";

  produceCountComparison($vdiSql, $legacySql, "EDA EntityTypeGraph", $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);
}

# for those entities in EntityTypeGraph that are in common between legacy and VDI, check their study-specific tables
# (ones that are not in common were reported above as issues)
sub testEdaStudySpecificTables {
  my ($dbh, $project, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds) = @_;

  # return a list of (udId, studyId, entityId) to test
  my @entities = findStudyEntities($dbh, $project, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus);
  my $count = scalar(@entities);
  print "Found $count study-entities\n";
  print STDERR "Found $count study-entities\n";

  my $bumTablesCount = 0;
  my $count = 0;
  foreach my $tuple (@entities) {
    my ($udId, $type, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId) = @$tuple;
    my $vdiId = $importedUds->{$udId}->{vdiId};
    my $userId = $wdkUdIds->{$udId};
    print "\n------------ Testing EDA | UD: $udId | VDI: $vdiId | User: $userId | vdi study: $vdiStudyId | legacy study: $legacyStudyId --------------\n";
    $bumTablesCount += testEdaAncestors($dbh, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId);
    $bumTablesCount += testEdaAttributeGraph($dbh, $type, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId);
    $bumTablesCount += testEdaAttributeValue($dbh, $type, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId) unless $project eq 'MicrobiomeDB';
#    $bumTablesCount += testEdaAttributes($dbh, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId);
    $count++;
    print STDERR "$count studies tested\n" if $count % 10 == 0;
  }
  print STDERR "$count studies tested\n";

  print "Found $bumTablesCount bad tables out of " . ($count * 4) . "\n\n";
}

# find (study, entity) tuples that are in common between legacy and VDI
sub findStudyEntities {
  my ($dbh, $project, $vdiDatasetsSchema, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus) = @_;

  my $sql = "
select distinct id.udId, d.type_name, etg.internal_abbrev as v_internal_abbrev, s.internal_abbrev as v_study_internal_abbrev, legacy.internal_abbrev as l_internal_abbrev, legacy.study_internal_abbrev as l_study_internal_abbrev
from $idMapTable id, $vdiDatasetsSchema.entitytypegraph etg, $vdiControlSchema.dataset_project p,
     $vdiDatasetsSchema.study s,
     $vdiControlSchema.dataset d,
(select d.user_dataset_id, etg.internal_abbrev, s.internal_abbrev as study_internal_abbrev
 from apidbuserdatasets.datasetattributes$DBLINK d, apidbuserdatasets.entitytypegraph$DBLINK etg, 
 apidbuserdatasets.UserDatasetEvent$DBLINK e, apidbuserdatasets.study$DBLINK s
 where d.user_dataset_id < $maxUdId
 and d.study_stable_id = etg.study_stable_id
 and d.study_stable_id = s.stable_id
 and e.user_dataset_id = d.user_dataset_id
 and e.status = 'complete' and e.event_type = 'install'
) legacy
where s.user_dataset_id = id.vdiId
and d.dataset_id = id.vdiId
and p.project_id = '$project'
and p.dataset_id = id.vdiId
and legacy.user_dataset_id = id.udId
and etg.study_stable_id = s.stable_id
and id.udId < $maxUdId
order by udId
";
  my $count;
  my $sth = $dbh->prepare($sql);
  $sth->execute();

  my @commonStudyEntities;
  # loop through all studies/entities, and generate table names for each
  while (my ($udId, $type, $v_entityId, $v_studyId, $l_entity_id, $l_study_id) = $sth->fetchrow_array) {
    $count += 1;
    push(@commonStudyEntities, [$udId, $type, $v_studyId, $v_entityId, $l_study_id, $l_entity_id]);
  }
  return @commonStudyEntities;
}

sub testEdaAncestors {
  my ($dbh, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId) = @_;

  my $vdiTableName = "ancestors_${vdiStudyId}_$vdiEntityId";
  my $legacyTableName = "ancestors_${legacyStudyId}_$legacyEntityId";

  return 1 unless testEdaTablePairExists($dbh, "Ancestors", $vdiDatasetsSchema, $vdiTableName, $legacyTableName);

  $legacyTableName = "$legacyTableName$DBLINK";

  my $vdiSql = "
select ${vdiEntityId}_stable_id as ID from $vdiDatasetsSchema.ancestors_${vdiStudyId}_$vdiEntityId
";

  my $legacySql = "
select ${legacyEntityId}_stable_id as ID from apidbuserdatasets.ancestors_${legacyStudyId}_$legacyEntityId$DBLINK
";

  my $sql = "$legacySql MINUS $vdiSql";
  my $foundBad = runEdaMinus($dbh, $sql, "Ancestors", "Legacy minus VDI ($legacyTableName minus $vdiTableName)", $udId);
  $sql = "$vdiSql MINUS $legacySql";
  $foundBad |= runEdaMinus($dbh, $sql, "Ancestors", "VDI minus Legacy ($vdiTableName minus $legacyTableName)", $udId);
  return $foundBad;
}

sub testEdaAttributeValue {
  my ($dbh, $type, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId) = @_;

  my $vdiTableName = "attributevalue_${vdiStudyId}_$vdiEntityId";
  my $legacyTableName = "attributevalue_${legacyStudyId}_$legacyEntityId";

  return 1 unless testEdaTablePairExists($dbh, "AttributeValue", $vdiDatasetsSchema, $vdiTableName, $legacyTableName);

  $legacyTableName .= $DBLINK;

  my $attrStblId = $type eq 'biom'? 'attribute_stable_id' : 'upper(attribute_stable_id)';
  my $vdiSql = "
select ${vdiEntityId}_stable_id as entity_id,
$attrStblId as attr_stable_id,
number_value, date_value, string_value
from $vdiDatasetsSchema.$vdiTableName
";

  my $else = $type eq 'biom'? 'ELSE attribute_stable_id' : "ELSE 'VAR_' || substr(RAWtoHEX(STANDARD_HASH(replace(attribute_stable_id, '.', '_'), 'SHA1')), 0, 16)" ;
  my $legacySql = "
select ${legacyEntityId}_stable_id as entity_id,
(CASE WHEN attribute_stable_id = 'TEMP_longitude' THEN 'OBI_0001621'
      $else
      END) as attr_stable_id,
number_value, date_value, string_value
from apidbuserdatasets.$legacyTableName
";

  my $sql = "select * from ($legacySql MINUS $vdiSql) order by entity_id, attr_stable_id, number_value";
  my $foundBad = runEdaMinus($dbh, $sql, "AttributeValue", "Legacy minus VDI($legacyTableName minus $vdiTableName)", $udId);
  $sql = "select * from ($vdiSql MINUS $legacySql) order by entity_id, attr_stable_id, number_value";
  $foundBad |= runEdaMinus($dbh, $sql, "AttributeValue", "VDI minus Legacy ($vdiTableName minus $legacyTableName)", $udId);
  return $foundBad;
}


sub testEdaAttributeGraph {
  my ($dbh, $type, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId) = @_;

  my $vdiTableName = "attributegraph_${vdiStudyId}_$vdiEntityId";
  my $legacyTableName = "attributegraph_${legacyStudyId}_$legacyEntityId";

  return 1 unless testEdaTablePairExists($dbh, "AttributeGraph", $vdiDatasetsSchema, $vdiTableName, $legacyTableName);

  $legacyTableName .= $DBLINK;

  my $vdiSql = "
select display_name, definition, display_type, hidden,
case when data_type = 'number' or data_type = 'integer' then to_char(to_number(round(range_min, 2))) else range_min end as rounded_range_min,
case when data_type = 'number' or data_type = 'integer' then to_char(to_number(round(range_max, 2))) else range_max end as rounded_range_max,
case when data_type = 'number' or data_type = 'integer' then to_char(to_number(round(mean, 2))) else mean end as rounded_mean,
is_repeated,
has_values, data_type, distinct_values_count, is_multi_valued, data_shape, unit, scale, precision 
from $vdiDatasetsSchema.$vdiTableName
";

#$vdiSql = "select display_name from  $vdiDatasetsSchema.$vdiTableName";
  my $displNm = $type eq 'isasimple'? "replace(display_name, '.', '_') as display_name" : "display_name";

  my $legacySql = "
select $displNm, definition, display_type, hidden,
case when data_type = 'number' or data_type = 'integer' then to_char(to_number(round(range_min, 2))) else range_min end as rounded_range_min,
case when data_type = 'number' or data_type = 'integer' then to_char(to_number(round(range_max, 2))) else range_max end as rounded_range_max,
case when data_type = 'number' or data_type = 'integer' then to_char(to_number(round(mean, 2))) else mean end as rounded_mean,
is_repeated,
 has_values, data_type, distinct_values_count, is_multi_valued, data_shape, unit, scale, precision 
from apidbuserdatasets.$legacyTableName
";
#$legacySql = "select display_name from apidbuserdatasets.$legacyTableName";
  my $sql = "select * from ($legacySql MINUS $vdiSql) order by display_name";
  my $foundBad = runEdaMinus($dbh, $sql, "AttributeGraph", "Legacy minus VDI ($legacyTableName minus $vdiTableName)", $udId);
  $sql = "select * from ($vdiSql MINUS $legacySql) order by display_name";
  $foundBad |= runEdaMinus($dbh, $sql, "AttributeGraph", "VDI minus Legacy ($vdiTableName minus $legacyTableName)", $udId);
  return $foundBad;
}

sub testEdaAttributes {
  my ($dbh, $vdiDatasetsSchema, $vdiStudyId, $vdiEntityId, $legacyStudyId, $legacyEntityId, $udId) = @_;

  my $vdiTableName = "attributes_${vdiStudyId}_$vdiEntityId";
  my $legacyTableName = "attributes_${legacyStudyId}_$legacyEntityId";

  return 1 unless testEdaTablePairExists($dbh, "Attributes", $vdiDatasetsSchema, $vdiTableName, $legacyTableName);

  $legacyTableName .= $DBLINK;

  # get (colName, uc(colName)) tuples, sorted by uc
  my @vdiColNames = sort {$a->[1] cmp $b->[1]} findTableColumns($dbh, $vdiDatasetsSchema, $vdiTableName, "");
  my $vdiColNamesStr = join(", ", map { $_->[0] } @vdiColNames);
  my @legacyColNames = sort {$a->[1] cmp $b->[1]} findTableColumns($dbh, 'apidbuserdatasets', $legacyTableName, $DBLINK);
  my $legacyColNamesStr = join(", ", map { "'$_->[0]'" }  @legacyColNames);

  if (scalar(@vdiColNames) != scalar(@legacyColNames)) {
    print "Attributes table column counts disagree\n";
    return 1;
  }

  for (my $i=0; $i<scalar(@vdiColNames); $i++) {
    if (@vdiColNames[$i]->[1] ne @legacyColNames[$i]->[1]) {
      print "Attributes tables $vdiTableName and $legacyTableName have different column names\n";
      print "VDI: $vdiColNamesStr\n";
      print "Legacy: $legacyColNamesStr\n";
      return 1;
    }
  }

  my $vdiT = "$vdiDatasetsSchema.$vdiTableName";
  my $vdiSql = "select count(*) from $vdiT";
  my $sth = $dbh->prepare($vdiSql);
  $sth->execute();
  my ($vdiRowCount) = $sth->fetchrow_array;

  my $legacyT = "apidbuserdatasets.$legacyTableName$DBLINK";
  my $legacySql = "select count(*) from $legacyT";
  $sth = $dbh->prepare($legacySql);
  $sth->execute();
  my ($legacyRowCount) = $sth->fetchrow_array;
  if ($legacyRowCount != $vdiRowCount && $legacyRowCount != 0) {
    print "Attributes tables $vdiTableName and $legacyTableName have different row counts.  VDI: $vdiRowCount Legacy: $legacyRowCount\n";
    return 1;
  }
  return 0;
}

sub testEdaTablePairExists {
  my ($dbh, $prefix, $vdiDatasetsSchema, $vdiTableName, $legacyTableName) = @_;

  my $vdiExists = testTableExists($vdiDatasetsSchema, $vdiTableName, "");
  my $legacyExists = testTableExists('apidbuserdatasets', $legacyTableName, $DBLINK);

  unless ($vdiExists && $legacyExists) {
    print "MISSING VDI TABLE $vdiTableName\n" unless $vdiExists;
    print "MISSING LEGACY TABLE $legacyTableName\n" unless $legacyExists;
    return 0;
  }
  return 1;
}

sub testTableExists {
  my ($schemaName, $tableName, $dblink) = @_;

  my $sql =
"select count(*) from sys.all_objects$dblink where owner = upper('$schemaName')
and object_name = upper('$tableName')";

  my $sth = $dbh->prepare($sql);
  $sth->execute();
  my ($count) = $sth->fetchrow_array;
  return $count;
}

sub runEdaMinus {
  my ($dbh, $minusSql, $tableName, $title, $udId) = @_;

  my $sql = "select * from ($minusSql) where rownum <= 20";
  my $sth = $dbh->prepare($sql);
  $sth->execute();
  my $wroteHeader = 0;
  while (my @row = $sth->fetchrow_array) {
    # write out header (once) only if we have some bummer rows
    if (!$wroteHeader) {
      print STDOUT "\n==== EDA $tableName - $title - UD ID: $udId (20 rows max) ====\n";
      $wroteHeader = 1;
    }
    print join("\t", @row) . "\n";
  }
  return $wroteHeader;
}

sub findTableColumns {
  my ($dbh, $schema, $tableName, $dblink) = @_;

  my $sql = "select column_name from all_tab_columns$dblink where owner = upper('$schema') and table_name = upper('$tableName')";

  my $sth = $dbh->prepare($sql);
  $sth->execute();
  my @columns;
  while (my ($colName) = $sth->fetchrow_array) {
    $colName = 'OBI_0001621' if $colName eq 'TEMP_longitude';
    push(@columns, [$colName, uc($colName)]);
  }
  return @columns;
}


sub testGeneList {
  my ($dbh, $project, $vdiDatasetsSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds) = @_;

  my $vdiSql = "
select id.udId, count(gene_source_id)
from $idMapTable id, $vdiDatasetsSchema.ud_geneid g, $vdiControlSchema.dataset_project p
where g.user_dataset_id = id.vdiId
and id.udId < $maxUdId
and p.project_id = '$project'
and p.dataset_id = id.vdiId
group by id.udId
";

  my $legacySql = "
select g.user_dataset_id, count(distinct gene_source_id)
from apidbuserdatasets.ud_geneid$DBLINK g, apidbuserdatasets.UserDatasetEvent$DBLINK e,
  apidbuserdatasets.userdatasetproject$DBLINK p
where g.user_dataset_id < $maxUdId
and g.user_dataset_id = e.user_dataset_id
and e.status = 'complete' and e.event_type = 'install'
AND p.user_dataset_id = g.user_dataset_id
AND p.project = '$project'
group by g.user_dataset_id
";
  print STDERR "$vdiSql\n";

  produceCountComparison($vdiSql, $legacySql, "Gene List", $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);
}

sub testBigwig {
  my ($importedUds, $targetDir, $expectedUdFiles, $vdiInstallStatus) = @_;

  print STDOUT "MISSING BIGWIG FILES\n";
  return testFiles($importedUds, $targetDir, $expectedUdFiles, 'BigwigFiles', $vdiInstallStatus);
}

sub testFiles {
  my ($importedUds, $targetDir, $expectedUdFiles, $type, $vdiInstallStatus) = @_;
  my $bwFiles = $expectedUdFiles->{$type};

  foreach my $udId (sort keys %$importedUds) {
    my $vdiId = $importedUds->{$udId}->{vdiId};
    my $status = checkUdFiles($udId, $vdiId, $targetDir, $bwFiles);
    if ($status->{missingDir}) {
      print STDOUT "$udId\tmissing-directory\t$importedUds->{$udId}->{msg}\t$vdiInstallStatus->{$udId}->{msg}\n";
      next;
    }
    my $missing = $status->{missingFiles};
    print STDOUT "$udId\t" . join(', ', @$missing) . "\n" if scalar @$missing;
  }
  print STDOUT "\n";
}

sub checkUdFiles {
  my ($udId, $vdiId, $targetDir, $expectedUdFiles) = @_;
  my $expectedFiles = $expectedUdFiles->{$udId};

  my $return = {missingDir=>0, missingFiles=>[]};
  unless ($expectedFiles && scalar @$expectedFiles) {
    return $return;
  }

  unless (-d "$targetDir/$vdiId") {
    $return->{missingDir} = 1;
    return $return;
  }
  opendir my $dir, "$targetDir/$vdiId" or die "Cannot open directory $targetDir/$udId: $!";
  my @foundFiles = readdir $dir;
  closedir $dir;
  foreach my $f (@$expectedFiles) {
    my $missingFiles = $return->{missingFiles};
    push(@$missingFiles, $f) unless grep(/^$f$/, @foundFiles);
  }
  return $return;
}

sub testRnaSeq {
  my ($dbh, $project, $vdiDatasetsSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds, $targetDir, $expectedUdFiles) = @_;

  my $vdiSql = "
select id.udId, count(na_feat_expression_id)
from $idMapTable id, $vdiDatasetsSchema.ud_profileset p,
  $vdiDatasetsSchema.ud_protocolappnode n, $vdiDatasetsSchema.ud_nafeatureexpression e, $vdiControlSchema.dataset_project p
where p.user_dataset_id = id.vdiId
and id.udId < $maxUdId
and n.profile_set_id = p.profile_set_id
and e.protocol_app_node_id = n.protocol_app_node_id
and p.project_id = '$project'
and p.dataset_id = id.vdiId
group by id.udId
";

  my $legacySql = "
select p.user_dataset_id, count(na_feat_expression_id)
from apidbuserdatasets.ud_profileset$DBLINK p, apidbuserdatasets.UserDatasetEvent$DBLINK e,
  apidbuserdatasets.ud_protocolappnode$DBLINK n, apidbuserdatasets.ud_nafeatureexpression$DBLINK ex, apidbuserdatasets.userdatasetproject$DBLINK pr
where p.user_dataset_id < $maxUdId
and p.user_dataset_id = e.user_dataset_id
AND pr.user_dataset_id = e.user_dataset_id
AND pr.project = '$project'
and e.status = 'complete' and e.event_type = 'install'
and n.profile_set_id = p.profile_set_id
and ex.protocol_app_node_id = n.protocol_app_node_id
group by p.user_dataset_id
";

  produceCountComparison($vdiSql, $legacySql, "Rna Seq", $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);

  print STDOUT "MISSING RNASEQ FILES\n";
  return testFiles($importedUds, $targetDir, $expectedUdFiles, 'RnaSeq', $vdiInstallStatus);

}

sub testShares {
  my ($dbh, $project, $vdiControlSchema, $idMapTable, $maxUdId, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds) = @_;

  my $vdiSql = "
select m.udId as user_dataset_id, user_id 
from $vdiControlSchema.AvailableUserDatasets v, $idMapTable m, $vdiControlSchema.dataset_project p
where v.user_dataset_id = m.vdiId
and p.project_id = '$project'
and p.dataset_id = m.vdiId
";

  my $legacySql = "
select * from
(select s.user_dataset_id, recipient_user_id 
from ApiDBUserDatasets.UserDatasetSharedWith$DBLINK s, apidbuserdatasets.userdatasetproject$DBLINK p
where s.user_dataset_id < $maxUdId
AND p.user_dataset_id = s.user_dataset_id
AND p.project = '$project'
union
select s.user_dataset_id, user_id
from ApiDBUserDatasets.UserDatasetOwner$DBLINK s, apidbuserdatasets.userdatasetproject$DBLINK p
where s.user_dataset_id < $maxUdId
AND p.user_dataset_id = s.user_dataset_id
AND p.project = '$project'
)
";

  produceCountComparison($vdiSql, $legacySql, "Sharing", $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds);
}

sub produceCountComparison {
  my($vdiSql, $legacySql, $udType, $importedUds, $vdiInstallStatus, $legacyInstallStatus, $wdkUdIds) = @_;

  #############################################################
  # run legacy MINUS VDI, and explain each row
  #############################################################

  my $sql = "$legacySql
MINUS
$vdiSql
";

  my $count = 0;
  my $invalidCount;
  my $sth = $dbh->prepare($sql);
  $sth->execute();
  print STDOUT "==== $udType - legacy minus VDI ====\n";
  print STDOUT "VDI-ID\tUD-ID\tcount\timport-status\tinstall-status\n";
  while (my @row = $sth->fetchrow_array) {
    $count += 1;
    my $udId = $row[0];
    my $importInfo = $importedUds->{$udId};   # the record from tinydb
    my $importTag;                            # by default no tag, which means import was OK
    if (!$importInfo) {
      # if not in tinydb, then either WDK did not supply it, or it went missing during import
      $importTag = $wdkUdIds->{$udId}? "import-missing" : "wdk-missing";
    } else {
      $importTag = "import-invalid" unless $importInfo->{valid};
    }
    my $reportedMsg = $importInfo->{msg};   # the explanation provided by VDI
    my $vdiInstallTag;
    if ($vdiInstallStatus->{$udId}) {
      $vdiInstallTag = $vdiInstallStatus->{$udId}->{status};
      $reportedMsg = $vdiInstallStatus->{$udId}->{msg};
    } else {
      # if no record of install then apply a tag, unless explained by problem with import
      $vdiInstallTag = "install-absent" unless $importTag;
    }
    $invalidCount += $importedUds->{$udId};
    print STDOUT $importedUds->{$udId}->{vdiId} . "\t" . join("\t", @row) . "\t$importTag\t$vdiInstallTag\t$reportedMsg\n";
  }
  print "$udType - legacy minus VDI count: $count\n";
  print STDOUT "\n";


  #############################################################
  # run VDI MINUS legacy, and explain each row
  #############################################################

  my $sql = "$vdiSql
MINUS
$legacySql
";

  $count = 0;
  my $sth = $dbh->prepare($sql);
  $sth->execute();
  print STDOUT "==== $udType - VDI minus legacy ====\n";
  print STDOUT "VDI-ID\tUD-ID\tcount\timport-status\tinstall-status\n";
  while (my @row = $sth->fetchrow_array) {
    my $msg = $legacyInstallStatus->{$row[0]}? $legacyInstallStatus->{$row[0]} : 'absent';
    print STDOUT $importedUds->{$row[0]}->{vdiId} . "\t" . join("\t", @row) . "\t$msg\n";
    $count+=1;
  }

  print "$udType - VDI minus legacy count: $count\n";
  print STDOUT "\n";

}

